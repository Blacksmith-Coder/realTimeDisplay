package uk.ac.le.sppg.superdarn.fitData;



import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.ShortBuffer;
import java.nio.channels.FileChannel;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.zip.DataFormatException;
import java.util.zip.GZIPInputStream;

//import java.lang.Exception.*;

/**
 *
 * The <code>FitFileReader</code> class is used for reading SuperDARN fit data from the
 * files generated by fitacf.
 * These files can normally be identified by the suffix .fit, or if they are 
 * compressed, fit.gz.
 * <p>
 * This class can read from either normal or compressed fit files.
 * <p>
 * Header information from the fit file is contained in the public fields 
 * {@link #header header}, {@link #dateString dateString},  
 * {@link #remainder remainder}, {@link #majorRev majorRev} and
 * {@link #minorRev minorRev}.
 *
 * @author nigel
 */
public class FitFileReader extends FitReader {

    /**
     * fit file header
     */
    public String header;
    /**
     * the date/time the fit file was created (nothing to do with
     * the time of the data in the file).
     */
    public String dateString;
    /**
     * any text remaining in the header after other fields have
     * been extracted.
     * <p>
     * Additional info can be added to the fit file when it is written.
     */
    public String remainder;
    
    /**
     * major revision number of the fit file format
     */
    public byte majorRev;
    /**
     * minor revision number of the fit file format
     */
    public byte minorRev;
    
    /*
     * OS under which data was written
     */
    public String OS;

    File file;
    String fileName;
    
    FileInputStream in;
    DataInputStream dataIn;
    FileChannel channel;
    
    short fitRecordLength;
    short inxRecordLength;
    
    
    
    static Pattern revPattern;
    
    static final int FIT_RECL = 1024;

    ByteBuffer dataBuffer;
    byte[] bufferArray;
    
    // pattern for matching the major and minor revision in the header.
    static { 
        try {
            revPattern = Pattern.compile( ".*fitacf.*version\\s+(\\d+)\\.(\\d+)\\s+\\((\\w+)" );
        }
        catch( PatternSyntaxException e ) { 
            System.out.println( "FileReader: failed to compile regular expression" );
        }
    }
            
    
    /**
     * Opens the file for reading by creating a FileInputStream.
     * If the filename ends in .gz it creates a GZIPInputStream.
     * <p>
     * After opening the file it reads the file headers and initializes the fields
     * header, dateString, remainder, majorRev and minorRev.
     * 
     * @param file
     * name of the file from which to read fit data records
     * 
     * @throws FileNotFoundException
     * @throws IOException
     */

    public FitFileReader( String file )
        throws FileNotFoundException, IOException  {
        init(file);
    }
    
    public FitFileReader( File file )
        throws FileNotFoundException, IOException  {
        init(file.getAbsolutePath());
    }

    private void init(String file)
    throws FileNotFoundException, IOException  {
        
        fileName = new String( file );
    	this.file = new File( file );

        // get an InputStream on the file
        in = new FileInputStream( file );
        channel = in.getChannel();
        
        // get a DataInputStream which can be used to read words.
        // if it's gzipped wrap it in a ZipInputStream
        if ( fileName.endsWith( ".gz" ) )
            dataIn = new DataInputStream( new GZIPInputStream( in ) );
        else
            dataIn = new DataInputStream( in );

        readHeader();
    }
    
    private void readHeader() 
    throws IOException  {
        
        // read the fit and inx lengths (this is little endian)
        byte[] lengthBytes = new byte[4];
        dataIn.readFully( lengthBytes );
        
        // wrap the byte array in a ByteBuffer, this allows
        // reading of little endian data
        ByteBuffer bb = ByteBuffer.wrap( lengthBytes );
        bb.order( ByteOrder.LITTLE_ENDIAN );
        
        fitRecordLength = bb.getShort();
        
        inxRecordLength = bb.getShort();
        
        // read the header block which is the same length
        // as the data records (fitRecordLength);
        
        byte[] fitHeader = new byte[fitRecordLength-4];
        
        dataIn.readFully( fitHeader );
        
        // extract the header text
        
        int index;
        for ( index = 0; index<fitRecordLength; index++ ) {
            if ( fitHeader[index] == '\n' || fitHeader[index] == '\0' ) 
                break;
        }
        
        header = new String( fitHeader, 0, index-1 );
        
        if ( fitHeader[index] == '\n' || fitHeader[index] == '\0' )
            index++;
        
        // extract the date text
        
        int index2;
        for ( index2=0; index+index2<fitRecordLength; index2++ ) {
            if ( fitHeader[index2+index] == '\n' || fitHeader[index2+index] == '\0' ) 
                break;
        }
        
        dateString = new String( fitHeader, index, index2-1 );
        
        index += index2;
        if ( fitHeader[index] == '\n' || fitHeader[index] == '\0' )
            index++;
        
        // extract any remaining text.
        for ( index2=0; index+index2<fitRecordLength; index2++ ) {
            if ( fitHeader[index2+index] == '\n' || fitHeader[index2+index] == '\0' ) 
                break;
        }
        
        remainder = new String( fitHeader, index, index2-1 );
        
        // extract the major and minor revs.
        Matcher m = revPattern.matcher( header );
        
        if ( m.matches() && m.groupCount() > 2 ) {
            majorRev = (byte)Integer.parseInt( m.group( 1 ) );
            minorRev = (byte)Integer.parseInt( m.group( 2 ) );
            OS = m.group(3);
        }
        else {
            OS = "";
            minorRev = -1;
            majorRev = -1;
        } 
        

        // create a ByteBuffer for reading the data/
        // Make it a direct buffer for efficiency.
        
        //dataBuffer = ByteBuffer.allocateDirect( fitRecordLength );
        bufferArray = new byte[fitRecordLength];
        dataBuffer = ByteBuffer.wrap( bufferArray );
        dataBuffer.order( ByteOrder.LITTLE_ENDIAN );

    }


    public void rewind() 
    throws IOException {
    	if ( this.dataIn == null )
    	    throw new IOException( "FitReader: no data source open" );
        
//        channel.position(0);
//        readHeader();
        close();
        init(fileName);
    }
    
    /**
     * reads the next record from the fit file.
     * <p>
     * 
     * @return
     * returns a FitData object.  (@see #nextAsNet nextAsNet()).
     * @throws IOException - if an I/O error occurs.
     * At end-of-file it throws the sub-class EOFException.
     * @throws DataFormatException - if there is a problem in the format
     * of the data.
     */
    public FitData next( ) 
    throws IOException, DataFormatException {
    	    	
    	if ( this.dataIn == null )
    	    throw new IOException( "FitReader: no data source open" );
       
        // remember the location of the start of this record
        long location = channel.position();
        
        // create a FitData structure to unpack the data into.

        return readFitData( dataIn );
    		
    }
        
    
    /**
     * reads the next record from the fit file but returns it as a
     * compressed NetFitData object rather than a FitData object.
     * <p>
     * 
     * @return
     * returns a NetFitData object (@see #next next()).
     * @throws IOException - if an I/O error occurs.
     * At end-of-file it throws the sub-class EOFException.
     * @throws DataFormatException - if there is a problem in the format
     * of the data.
     */
    public NetFitData nextAsNet( ) 
        throws IOException, DataFormatException {
                
        if ( this.dataIn == null )
            throw new IOException( "FitReader: no data source open" );
        

       
        // create a FitData structure to unpack the data into.
        NetFitData fitData = readNetFitData( dataIn );
        
        
        return fitData;
    
    }
    
    // read a FitData record.
    
    FitData readFitData( DataInputStream dataIn ) 
    throws IOException, DataFormatException {
        
        // read the next data record. 
        //byte[] fitRawData = new byte[fitRecordLength];
        
        //byte[] bufferArray = dataBuffer.array();
        dataIn.readFully( bufferArray );
        dataBuffer.position( 0 );
 
        // wrap the data in a ByteBuffer so it can 
        // be read little endian.
        
        FitData result;
        
        if ( OS.equals("QNX") && majorRev == 1 && minorRev == 1 ) {
            result = new FitData110();
        }
        else {
            result = new FitData130();
        }
        
        // read the status word
        int recordNumber = dataBuffer.getInt();
        
        // a complete data record is made up of multple shorter records.
        // the fist has record number zero, and we should be reading this now.
        if ( recordNumber != 0 )
            throw new DataFormatException( "Not a parameter record" );
            
        // read the time
        int r_time = dataBuffer.getInt();

        // read the radar parms                   
        result.radarParms = new RadarParms();
        result.radarParms.read( dataBuffer );
        
        // read the pulse pattern
        int i;
        for ( i = 0; i < result.pulse.length; i++ )
            result.pulse[i] = dataBuffer.getShort();
        
        // read the lags
        for ( i = 0; i < result.lag[0].length; i++ )
            result.lag[0][i] = dataBuffer.getShort();
        for ( i = 0; i < result.lag[1].length; i++ )
            result.lag[1][i] = dataBuffer.getShort();
            
        // read the comment block
        for ( i = 0; i < COMBF_SIZE; i++ )
            result.combf[i] = (char)dataBuffer.get();
        
        // read the noise values
        result.noise.sky = dataBuffer.getInt();
        result.noise.lag0 = dataBuffer.getInt();
        result.noise.vel = dataBuffer.getInt();
        
        // read the zero lag power, slist and numlags arrays
        short[] pwr0 = new short[MAX_RANGE];
        short[] slist = new short[MAX_RANGE];
        byte[] numlags = new byte[MAX_RANGE];
        for ( i = 0; i < MAX_RANGE; i++ )
            pwr0[i] = dataBuffer.getShort();
        for ( i = 0; i < MAX_RANGE; i++ )
            slist[i] = dataBuffer.getShort();
        dataBuffer.get( numlags );
        
        // 
        int counter = 0;
        int index;
        for ( i = 0; i < result.radarParms.numberOfRanges; i++ ) {
            index = slist[i]-1;
                
            result.rangeData[i].lag0Power = pwr0[i] / 100.0;
            
            
            if ( slist[i] != 0 ) {
                counter++;
                
                result.xRangeData[index] = new RangeData();
                result.elevData[index] = new ElevData();
                
                result.rangeData[index].numberGoodLags = numlags[i];
            }
        }
        
        if ( counter > 0 ) {
            index = 0;
            int xflag;
            RangeData range;
            
            byte[] ranges = new byte[PART_RANGE];
            byte[] qflag = new byte[PART_RANGE];
            short[] pwr_l = new short[PART_RANGE];
            short[] pwr_l_err = new short[PART_RANGE];
            short[] pwr_s = new short[PART_RANGE];
            short[] pwr_s_err = new short[PART_RANGE];
            short[] vel = new short[PART_RANGE];
            short[] vel_err = new short[PART_RANGE];
            short[] w_l = new short[PART_RANGE];
            short[] w_l_err = new short[PART_RANGE];
            short[] w_s = new short[PART_RANGE];
            short[] w_s_err = new short[PART_RANGE];
            short[] phi0 = new short[PART_RANGE];
            short[] phi0_err = new short[PART_RANGE];
            short[] elev = new short[PART_RANGE];
            short[] elev_low = new short[PART_RANGE];
            short[] elev_high = new short[PART_RANGE];
            short[] sdev_l = new short[PART_RANGE];
            short[] sdev_s = new short[PART_RANGE];
            short[] sdev_phi = new short[PART_RANGE];
            short[] gscat = new short[PART_RANGE];
            
            while ( index < counter ) {
                
                // read the next data buffer
                dataIn.readFully( bufferArray );
                dataBuffer.position( 0 );
                
                recordNumber = dataBuffer.getInt();
                r_time = dataBuffer.getInt();
                xflag = dataBuffer.getInt();
                
                if ( recordNumber == 0 || xflag != 0 )
                    throw new DataFormatException( "Incorrect record type" );
                
                dataBuffer.get( ranges );
                
                dataBuffer.get( qflag );
                for ( i=0; i<PART_RANGE; i++ )
                    pwr_l[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    pwr_l_err[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    pwr_s[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    pwr_s_err[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    vel[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    vel_err[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    w_l[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    w_l_err[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    w_s[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    w_s_err[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    phi0[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    phi0_err[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    elev[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    elev_low[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    elev_high[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    sdev_l[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    sdev_s[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    sdev_phi[i] = dataBuffer.getShort();
                for ( i=0; i<PART_RANGE; i++ )
                    gscat[i] = dataBuffer.getShort();
                  
                for ( i=0; i<PART_RANGE && index<counter; i++ ) {
                    range = result.rangeData[ranges[i]-1];
                    
                    range.qualityFlag = (int)qflag[i];
                    range.groundScatterFlag = (gscat[i] != 0);
                    range.lambdaPower = pwr_l[i] / 100.0;
                    range.lambaPowerErr = pwr_l_err[i] / 100.0;
                    range.sigmaPower = pwr_s[i] / 100.0;
                    range.sigmaPowerErr = pwr_s_err[i] / 100.0;
                    range.lambdaSpectralWidth = w_l[i] / 10.0;
                    range.lambdaSpectralWidthErr = w_l_err[i] / 10.0;
                    range.sigmaSpectralWidth = w_s[i] / 10.0;
                    range.sigmaSpectralWidthErr = w_s_err[i] / 10.0;
                    range.velocity = vel[i] / 10.0;
                    range.velocityErr = vel_err[i] / 10.0;
                    range.sdevLambdaFit = sdev_l[i] / 1000.0;
                    range.sdevSigmaFit = sdev_s[i] / 1000.0;
                    
                    // don't ask me why this isn't sdev_phi/1000.
                    // I've just copied what Rob does in fit_read_current.
                    range.sdevPhaseFit = sdev_s[i] / 100.0;
                    
                    index++;
                }
            }
            
            
            // read cross correlation data.
            
            if ( result.radarParms.crossCorrelation ) {
                index = 0;
                
                while ( index < counter ) {
                    
                    // read the next data buffer
                    dataIn.readFully( bufferArray );
                    dataBuffer.position( 0 );
                    
                    recordNumber = dataBuffer.getInt();
                    r_time = dataBuffer.getInt();
                    
                    xflag = dataBuffer.getInt();
                    
                    if ( recordNumber == 0 || xflag == 0 )
                        throw new DataFormatException( "Incorrect xcorr record type" );
                    
                    dataBuffer.get( ranges );
                    dataBuffer.get( qflag );
                    for ( i=0; i<PART_RANGE; i++ )
                        pwr_l[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        pwr_l_err[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        pwr_s[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        pwr_s_err[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        vel[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        vel_err[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        w_l[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        w_l_err[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        w_s[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        w_s_err[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        phi0[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        phi0_err[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        elev[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        elev_low[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        elev_high[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        sdev_l[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        sdev_s[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        sdev_phi[i] = dataBuffer.getShort();
                    for ( i=0; i<PART_RANGE; i++ )
                        gscat[i] = dataBuffer.getShort();
                      
                    for ( i=0; i<PART_RANGE && index<counter; i++ ) {
                        range = result.xRangeData[ranges[i]-1];
                        
                        range.qualityFlag = qflag[i];
                        range.groundScatterFlag = (gscat[i] != 0 );
                        range.lambdaPower = pwr_l[i] / 100.0;
                        range.lambaPowerErr = pwr_l_err[i] / 100.0;
                        range.sigmaPower = pwr_s[i] / 100.0;
                        range.sigmaPowerErr = pwr_s_err[i] / 100.0;
                        range.lambdaSpectralWidth = w_l[i] / 10.0;
                        range.lambdaSpectralWidthErr = w_l_err[i] / 10.0;
                        range.sigmaSpectralWidth = w_s[i] / 10.0;
                        range.sigmaSpectralWidthErr = w_s_err[i] / 10.0;
                        range.velocity = vel[i] / 10.0;
                        range.velocityErr = vel_err[i] / 10.0;
                        range.sdevLambdaFit = sdev_l[i] / 1000.0;
                        range.sdevSigmaFit = sdev_s[i] / 1000.0;
                        
                        // don't ask me why this isn't sdev_phi/1000.
                        // I've just copied what Rob does in fit_read_current.
                        range.sdevPhaseFit = sdev_s[i] / 100.0;
                        
                        index++;
                    }
                }                
            
                    
            }
        }
                
        return result;
    }
    


    NetFitData readNetFitData( DataInputStream dataIn ) 
    throws IOException, DataFormatException {
        
        // read the next data record.
        //byte[] fitRawData = new byte[fitRecordLength];
        
        //byte[] bufferArray = dataBuffer.array();
        dataIn.readFully( bufferArray );
        dataBuffer.position( 0 );
 
        
        NetFitData result = new NetFitData();
        
        // read the status word
        int recordNumber = dataBuffer.getInt();
        
        if ( recordNumber != 0 )
            throw new DataFormatException( "Not a parameter record" );
            
        // read the time
        dataBuffer.getInt();

        // read the radar parms                   
        result.radarParms = new RadarParms();
        result.radarParms.read( dataBuffer );
        
        int position = dataBuffer.position();

        // skip the pulse pattern and lags
        if ( OS.equals("QNX") && majorRev == 1 && minorRev == 1 ) {
            position += PULSE_PAT_LEN_V110*2 + LAG_TAB_LEN_V110*4;
        }
        else {            
            position += PULSE_PAT_LEN_V130*2 + LAG_TAB_LEN_V130*4;
        }
        // skip the comment block
        position += COMBF_SIZE;
        
        // skip the noise values ( 3 ints )
        position += 12;

        // skip the zero lag power
        position += MAX_RANGE*2;
        
        
        // position the buffer to skip the data
        dataBuffer.position( position );
        
        
        // read slist
        int i;
        short[] slist = new short[MAX_RANGE];
        for ( i = 0; i < MAX_RANGE; i++ )
            slist[i] = dataBuffer.getShort();
        
        // skip numlags
        position = dataBuffer.position();
        position += MAX_RANGE;
        dataBuffer.position( position );        

        int nRanges = 0;
        
        for ( i = 0; i < result.radarParms.numberOfRanges; i++ ) {
            if ( slist[i] != 0 ) 
                nRanges++;

        }
                
        result.groundScatter = new boolean[nRanges];
        result.lambdaPower = new float[nRanges];
        result.lambdaSpectralWidth = new float[nRanges];
        result.velocity = new float[nRanges];
        result.ranges = new byte[nRanges];

        if ( nRanges > 0 ) {
            int index = 0;
            int xflag;
           
            byte[] ranges = new byte[PART_RANGE];
            //byte[] qflag = new byte[PART_RANGE];
            short[] pwr_l = new short[PART_RANGE];
            //short[] pwr_l_err = new short[PART_RANGE];
            //short[] pwr_s = new short[PART_RANGE];
            //short[] pwr_s_err = new short[PART_RANGE];
            short[] vel = new short[PART_RANGE];
            //short[] vel_err = new short[PART_RANGE];
            short[] w_l = new short[PART_RANGE];
            //short[] w_l_err = new short[PART_RANGE];
            //short[] w_s = new short[PART_RANGE];
            //short[] w_s_err = new short[PART_RANGE];
            //short[] phi0 = new short[PART_RANGE];
            //short[] phi0_err = new short[PART_RANGE];
            //short[] elev = new short[PART_RANGE];
            //short[] elev_low = new short[PART_RANGE];
            //short[] elev_high = new short[PART_RANGE];
            //short[] sdev_l = new short[PART_RANGE];
            //short[] sdev_s = new short[PART_RANGE];
            //short[] sdev_phi = new short[PART_RANGE];
            short[] gscat = new short[PART_RANGE];
            
            while ( index < result.ranges.length ) {
                
                // read the next data buffer
                dataIn.readFully( bufferArray );
                dataBuffer.position( 0 );
                
                recordNumber = dataBuffer.getInt();
                dataBuffer.getInt();
                xflag = dataBuffer.getInt();
                
                if ( recordNumber == 0 || xflag != 0 )
                    throw new DataFormatException( "Incorrect record type" );
                
                dataBuffer.get( ranges );
               
                // skip qflag
                position = dataBuffer.position();
                position += PART_RANGE;

				ByteBuffer bb = ByteBuffer.wrap( bufferArray, position, PART_RANGE*19*2);
				bb.order( ByteOrder.LITTLE_ENDIAN );

                ShortBuffer shortBuffer = bb.asShortBuffer();
                
                shortBuffer.get( pwr_l );

                // need to skip 3*PART_RANGE and reading the array
                // 3 extra times is the easiest way to do it.
                for ( i=0; i<=3; i++ )
                    shortBuffer.get( vel );
                
                shortBuffer.get( w_l );
                shortBuffer.get( w_l );
                
                for ( i=0; i<=11; i++ )
                    shortBuffer.get( gscat );
                                  
                
                for ( i=0; i<PART_RANGE && index<nRanges; i++ ) {
                    result.ranges[index] = (byte) ranges[i];
                    
                    result.groundScatter[index] = (gscat[i] != 0);
                    result.lambdaPower[index] = (float) pwr_l[i] / 100.0f;
                    result.lambdaSpectralWidth[index] = (float) w_l[i] / 10.0f;
                    result.velocity[index] = (float) vel[i] / 10.0f;
                   
                    index++;
                }
            }
            
            
            // skip cross correlation data.
            
            if ( result.radarParms.crossCorrelation ) {
                index = 0;
                
                while ( index < nRanges ) {
                    
                    // read the next data buffer
                    dataIn.readFully( bufferArray );
                      
                    index += PART_RANGE;
                    
                }           
                    
            }
        }
                
        return result;
    }


    /**
     * @see fitData.FitReader#close()
     */
    public void close() 
    throws IOException {  
        in.close();
        dataIn.close();    
    }
}
